#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in2,    lightSensor2,   sensorReflection)
#pragma config(Sensor, in7,    lightSensor,    sensorReflection)
#pragma config(Sensor, in8,    towerPot,       sensorPotentiometer)
#pragma config(Sensor, dgtl1,  topButton,      sensorTouch)
#pragma config(Sensor, dgtl2,  ultrasonic,     sensorSONAR_cm)
#pragma config(Sensor, dgtl4,  button2,        sensorTouch)
#pragma config(Sensor, dgtl6,  redLED,         sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port4,           towerMotor,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, openLoop, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Okarito.c"

void cleanup();
void init();

/****************************************************************/
/*    DO NOT MODIFY THIS FILE EXCEPT TO ADD NEW ROBOT STATES    */
/*              SEE OKARITO.C FOR MAIN ROBOT CODE               */
/****************************************************************/

task main() {
    init();

    while(currentState != STATE_DISABLED) {
        switch(currentState) {
        case STATE_ENABLED:
            currentState = STATE_WAITING;
            break;
        case STATE_WAITING:
            waitingForScan();
            break;
        case STATE_SCAN:
            scanForBeacon();
            break;
        case STATE_ROTATE:
            rotateTowardsBeacon();
            break;
        case STATE_DRIVE:
            driveOneMeter();
            break;
        case STATE_TURN:
            turn90Degs();
            break;
        case STATE_APPROACH:
            wait1Msec(250);
            approachTarget();
            break;
        case STATE_DEPART:
            departTarget();
            break;
        case STATE_TEST:
            testPeriodic();
            break;
         default:
            writeDebugStreamLine("Inside default switch block");
        }
    }

    cleanup();
}

//*********************************************
// Initialization code for the robot to execute
// when it begins its routine. Clears the debug
// stream, initializes the drivebase, and waits
// for a small amount of time to let any sensor
// values settle.
//
// @PARAM none
// @RETURN none
//*********************************************
void init() {
    clearDebugStream();
    driveInit();
    wait1Msec(250);
}

//*********************************************
// Cleanup code for the robot to execute when
// it is finished it's routine. Simply turns
// off all the motors and resets the encoders.
//
// @PARAM none
// @RETURN none
//*********************************************
void cleanup() {
    motor[rightMotor] = 0;
    motor[leftMotor]  = 0;
    motor[towerMotor] = 0;
    resetMotorEncoder(rightMotor);
    resetMotorEncoder(leftMotor);
}
