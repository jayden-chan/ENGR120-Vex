#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in4,    testing,        sensorPotentiometer)
#pragma config(Sensor, in5,    rightLightSensor, sensorReflection)
#pragma config(Sensor, in6,    lightSensor2,   sensorReflection)
#pragma config(Sensor, in7,    lightSensor,    sensorReflection)
#pragma config(Sensor, in8,    towerPot,       sensorPotentiometer)
#pragma config(Sensor, dgtl1,  topButton,      sensorTouch)
#pragma config(Sensor, dgtl2,  ultrasonic,     sensorSONAR_cm)
#pragma config(Sensor, dgtl4,  button2,        sensorTouch)
#pragma config(Sensor, dgtl10, LED1,           sensorDigitalOut)
#pragma config(Sensor, dgtl11, LED2,           sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port4,           towerMotor,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, openLoop, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
 * This file contains the robot's configuration
 * settings as well as the main entry point
 * for the code. It contains the finite state
 * machine code that determines the robot's
 * actions at any given point in time.
 *
 * @author Jayden Chan, Cobey Hollier
 * @date January 10, 2018
 */

#include "Okarito.c"

void cleanup();
void init();

//===============================================================
//    DO NOT MODIFY THIS FILE EXCEPT TO ADD NEW ROBOT STATES
//              SEE OKARITO.C FOR MAIN ROBOT CODE
//===============================================================

/**
 * The main method for the program. Contains
 * the finite state machine to control the
 * robot's actions.
 */
task main() {
    init();

    while(currentState != STATE_DISABLED) {
        switch(currentState) {
        case STATE_ENABLED:
            currentState = STATE_TEST;
            break;
        case STATE_WAITING:
            waitingForScan();
            break;
        case STATE_RECALLIBRATE:
            callibrate();
            break;
        case STATE_SCAN:
            scanForBeacon();
            break;
        case STATE_ROTATE:
            rotateTowardsBeacon();
            break;
        case STATE_DRIVE:
            driveOneMeter();
            break;
        case STATE_TURN:
            turn90Degs();
            break;
        case STATE_GETCLOSE:
            getClose();
            break;
        case STATE_SCAN2:
            scanForBeaconAgain();
            break;
        case STATE_APPROACH:
            wait1Msec(250);
            approachTarget();
            break;
        case STATE_DEPART:
            departTarget();
            break;
        case STATE_TEST:
            testPeriodic();
            break;
         default:
            writeDebugStreamLine("Inside default switch block");
        }
    }
    cleanup();
}

/**
 * Initialization code for the robot to execute
 * when it begins its routine. Clears the debug
 * stream, initializes the drivebase, and waits
 * for a small amount of time to let any sensor
 * values settle.
 */
void init() {
    clearDebugStream();
    turnOffAll();
    driveInit();
    lightHouseInit();
    wait1Msec(250);
}

/**
 * Cleanup code for the robot to execute when
 * it is finished it's routine. Simply turns
 * off all the motors and resets the encoders.
 */
void cleanup() {
    motor[rightMotor] = 0;
    motor[leftMotor]  = 0;
    motor[towerMotor] = 0;
    resetMotorEncoder(rightMotor);
    resetMotorEncoder(leftMotor);
}
