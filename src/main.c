#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    lightSensor,    sensorReflection)
#pragma config(Sensor, in8,    towerPot,       sensorPotentiometer)
#pragma config(Sensor, dgtl1,  topButton,      sensorTouch)
#pragma config(Sensor, dgtl2,  ultrasonic,     sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port9,           towerMotor,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, openLoop, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Includes
#include "DriveBase.c"
#include "RobotStates.h"

// Prototypes
void testPeriodic();
void cleanup();
void waitForButton();

RobotState currentState = STATE_DISABLED;

// Code
task main() {

    clearDebugStream();
    wait1Msec(250);
    waitForButton();

    while(currentState != STATE_DISABLED) {
        switch(currentState) {
        case STATE_ENABLED:
            currentState = STATE_TEST;
            break;
        case STATE_TEST:
            testPeriodic();
            break;
        }

        wait1Msec(1);
    }

    cleanup();
}

void testPeriodic() {
    writeDebugStreamLine("Test periodic running.\n");
    writeDebugStreamLine("Value of light sensor: %d", SensorValue[lightSensor]);
}

// General cleanup and safety code
void cleanup() {

    motor[rightMotor] = 0;
    motor[leftMotor] = 0;
    motor[towerMotor] = 0;
    resetMotorEncoder(rightMotor);
    resetMotorEncoder(leftMotor);
}

void waitForButton() {
    while(!SensorValue(topButton)) {
        wait1Msec(5);
    }

    currentState = STATE_ENABLED;
}
