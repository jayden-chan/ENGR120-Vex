#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    lightSensor,    sensorReflection)
#pragma config(Sensor, in2,    lightSensor2,   sensorReflection)
#pragma config(Sensor, in8,    towerPot,       sensorPotentiometer)
#pragma config(Sensor, dgtl1,  topButton,      sensorTouch)
#pragma config(Sensor, dgtl2,  ultrasonic,     sensorSONAR_cm)
#pragma config(Sensor, dgtl4,  button2,        sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port9,           towerMotor,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, openLoop, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Okarito.c"

void cleanup();
void init();

/****************************************************************/
/*    DO NOT MODIFY THIS FILE EXCEPT TO ADD NEW ROBOT STATES    */
/****************************************************************/

task main() {
    init();

    while(currentState != STATE_DISABLED) {
        switch(currentState) {
        case STATE_ENABLED:
            currentState = STATE_WAITING;
            break;
        case STATE_WAITING:
            waitingForButtons();
            break;
        case STATE_DRIVE:
            driveOneMeter();
            break;
        case STATE_TURN:
            turn90Degs();
            break;
        case STATE_APPROACH:
            wait1Msec(250);
            approachTarget();
            break;
        case STATE_DEPART:
            departTarget();
            break;
         default:
            writeDebugStreamLine("Inside default switch block");
        }
    }

    cleanup();
}

void init() {
    clearDebugStream();
    driveInit();

    last[0] = 0;
    last[1] = 0;
    last[2] = 0;
    last[3] = 0;
    last[4] = 0;

    wait1Msec(250);
}

// General cleanup and safety code
void cleanup() {

    motor[rightMotor] = 0;
    motor[leftMotor] = 0;
    motor[towerMotor] = 0;
    resetMotorEncoder(rightMotor);
    resetMotorEncoder(leftMotor);
}
